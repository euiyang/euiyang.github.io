# UBX 실행 압축된 notepad 디버깅  

notepad.exe  
![image](https://user-images.githubusercontent.com/65746019/118147006-1e11e180-b44a-11eb-8af5-3dad8481fa85.png)  

getmodulehacdleA로 imagebase를 가져오고 cmp 부분에서 MZ와 PE 비교  

notepad_upx
![image](https://user-images.githubusercontent.com/65746019/118147431-85c82c80-b44a-11eb-9358-b087e7e3dabb.png)  

upx로 압축된 파일의 entry point는 두번째 섹션의 끝부분으로 지정되어 있는데 첫번째 섹션은 메모리에서만 존재한다.  
esi(두번째 섹션 시작 주소)와 edi(첫번째 섹션 주소)가 동시에 세팅되면 esi에서 edi로 메모리 복사가 일어날 것임을 알 수 있다.  
esi에서 압축해제한 결과를 edi에 저장할 것이다.  

어떤 파일을 트레이스 할때 명령어  
animate into(ctrl+F7): 화면 표시 되고 step into  
        over(ctrl+F8): 화면 표시 되고 step over  
trace   into(ctrl+F11): 화면 표시 안 되고 step into  
        over(ctrl+F12): 화면 표시 안 되고 step over  

decode loop:  
esi가 가리키는 두번째 섹션의 주소에서 값을 차례대로 읽어 edi의 주소에 값을 써주는 루프이다.  

원본 코드의 call/jmp 명령어의 des 주소 복원 루프:  
![image](https://user-images.githubusercontent.com/65746019/118151488-a6928100-b44e-11eb-9c92-ea302b42ef4b.png)   

IAT 세팅 루프:  

![image](https://user-images.githubusercontent.com/65746019/118151643-cde94e00-b44e-11eb-9185-67ce2508f332.png)

edi가 가르키는 곳은 api 이름 문자열이 저장되는 곳이며, 이곳은 실행 압축시에 프로그램에서 사용되는 api를 저장한 장소이다.  

이후에 OEP로 점프해서 제어를 돌려준다.  

OEP 빨리 찾기  

1) EP 코드가 PUSHSD/POPAD로 둘러싸여 있고, OEP 코드로 가는 JMP 명령어가 POPAD 명령어 이후에 나타나므로 JMP에 break를 설치하면 OEP로 바로 간다.  
2) 스택에 하드웨어 br 설치: PUSHAD 명령어로 eax부터 edi까지 스택에 저장되므로 스택의 esp 부분에 bp를 설치하면 POPAD가 호출되는 순간 제어가 멈추고 JMP 명령어가 밑에 보인다.  



# Base Relocation Table  
PE 파일의 재배치에 사용되는 테이블  

PE 파일의 재배치:  
PE 파일이 프로세스 가상 메모리에 로딩 될 때 PE 헤더의 ImageBase 주소에 로딩되며, DLL 파일은 다른 DLL 파일이 이미 ImageBase에 로딩 되어 있으면 다른 자리에 로딩된다.  
이렇게 다른 주소로 로딩될 때 수행되는 작업을 PE 파일 재배치라 한다.  

DLL/SYS: 

EXE: 원래는 가장 먼저 메모리에 올라와서 재배치 과정이 필요없었지만 vista 이후 ASLR(DLL/sys파일도 동일)로 보안이 강화되어 실행마다 랜덤한 주소에 로딩이 된다.  


