# UBX 실행 압축된 notepad 디버깅(15)  

notepad.exe  
![image](https://user-images.githubusercontent.com/65746019/118147006-1e11e180-b44a-11eb-8af5-3dad8481fa85.png)  

getmodulehacdleA로 imagebase를 가져오고 cmp 부분에서 MZ와 PE 비교  

notepad_upx  
![image](https://user-images.githubusercontent.com/65746019/118147431-85c82c80-b44a-11eb-9358-b087e7e3dabb.png)  

upx로 압축된 파일의 entry point는 두번째 섹션의 끝부분으로 지정되어 있는데 첫번째 섹션은 메모리에서만 존재한다.  
esi(두번째 섹션 시작 주소)와 edi(첫번째 섹션 주소)가 동시에 세팅되면 esi에서 edi로 메모리 복사가 일어날 것임을 알 수 있다.  
esi에서 압축해제한 결과를 edi에 저장할 것이다.  

어떤 파일을 트레이스 할때 명령어  
animate into(ctrl+F7): 화면 표시 되고 step into  
        over(ctrl+F8): 화면 표시 되고 step over  
trace   into(ctrl+F11): 화면 표시 안 되고 step into  
        over(ctrl+F12): 화면 표시 안 되고 step over  

decode loop:  
esi가 가리키는 두번째 섹션의 주소에서 값을 차례대로 읽어 edi의 주소에 값을 써주는 루프이다.  

원본 코드의 call/jmp 명령어의 des 주소 복원 루프:  
![image](https://user-images.githubusercontent.com/65746019/118151488-a6928100-b44e-11eb-9c92-ea302b42ef4b.png)   

IAT 세팅 루프:  

![image](https://user-images.githubusercontent.com/65746019/118151643-cde94e00-b44e-11eb-9185-67ce2508f332.png)

edi가 가르키는 곳은 api 이름 문자열이 저장되는 곳이며, 이곳은 실행 압축시에 프로그램에서 사용되는 api를 저장한 장소이다.  

이후에 OEP로 점프해서 제어를 돌려준다.  

OEP 빨리 찾기  

1) EP 코드가 PUSHSD/POPAD로 둘러싸여 있고, OEP 코드로 가는 JMP 명령어가 POPAD 명령어 이후에 나타나므로 JMP에 break를 설치하면 OEP로 바로 간다.  
2) 스택에 하드웨어 br 설치: PUSHAD 명령어로 eax부터 edi까지 스택에 저장되므로 스택의 esp 부분에 bp를 설치하면 POPAD가 호출되는 순간 제어가 멈추고 JMP 명령어가 밑에 보인다.  



# Base Relocation Table(16)  
PE 파일의 재배치에 사용되는 테이블이며, Datadirectory 배열에서 여섯번째 항목에 있다.  

IMAGE_BASE_RELOCATION 구조체  
![image](https://user-images.githubusercontent.com/65746019/118156799-c0cf5d80-b454-11eb-807f-ca69ea34e9a6.png)  
![image](https://user-images.githubusercontent.com/65746019/118156823-c6c53e80-b454-11eb-843d-3e6b0b93e193.png)  

1) virtual address: base address로 실제로는 RVA 값임.  
2) SizeOfBlock: 각 단위 블록 크기  
3) Typeoffset: 이 offset 이후로 Word 타입의 배열이 따라옴  


PE 파일의 재배치:  
PE 파일이 프로세스 가상 메모리에 로딩 될 때 PE 헤더의 ImageBase 주소에 로딩되며, DLL 파일은 다른 DLL 파일이 이미 ImageBase에 로딩 되어 있으면 다른 자리에 로딩된다. 이렇게 다른 주소로 로딩될 때 수행되는 작업을 PE 파일 재배치라 한다.  

DLL/SYS: imagebase에 로딩을 실패하면 비어있는 주소에 로딩시킨다.  
EXE: 원래는 가장 먼저 메모리에 올라와서 재배치 과정이 필요없었지만 vista 이후 ASLR(DLL/sys파일도 동일)로 보안이 강화되어 실행마다 랜덤한 주소에 로딩이 된다.  

코드에는 하드코딩된 메모리 주소가 있는데 이러한 주소를 현재 로딩된 주소에 맞게 변경시켜주는 과정이 PE 파일 재배치이다.  

재배치 원리:  
1) 프로그램에서 하드코딩된 주소 위치를 찾음  
2) 값을 읽은 후 imagebase만큼 뺀다(VA-imagebase=RVA)  
3) 실제 로딩 주소를 더한다(RVA+ loading add=new VA)  

1번에서 하드코딩된 주소의 위치는 relocation table이라고 하드코딩된 주소의 위치를 모아놓은 목록이 있고 Base Relocation Table 항목을 따라가면 이 relocation table을 찾을 수 있다.  

base relocation talbe 해석 방법:  
virtual address가 RVA 1000이고 sizeofblock이 150이면 typeoffset의 시작주소가 rva 1000이고 블록 전체 크기가 150이다.  
typeoffset값은 2바이트 크기이며 type(4bit)+ offset(12bit)가 합쳐진 크기이다. 따라서 typeoffset이 3420값이면 type이 3(PE에서는 3, PE+에서는 A), offset이 420이다. 이때 offset의 값은 virtual address 기준의 offset이므로 하드코딩 주소의 offset은 1000(VA)+ offset(420)= 1420(RVA)가 된다.  
이 값을 로딩된 주소에 더하면 하드 코딩된 주소가 나온다. 이외에 다음 offset을 더하면 다음 하드 코딩된 주소가 나오게 된다.  



# 실행파일에서 .reloc 섹션 제거(17)  
exe 형식의 pe 파일에서 base relocation table 항목은 실행에 큰 영향을 끼치지 않으므로 제거해 보겠다.  

제거 순서는 다음과 같다  
1) .reloc 섹션 헤더 정리(00으로)  
2) .reloc 섹션 제거(delete)  
3) IMAGE_FILE_HEADER 수정(number of section -1)  
4) IMAGE_OPTIONAL_HEADER 수정(image_optional_header의 size of image에서 .reloc 섹션의 virtual size를 빼고 section alignment에 맞게 확장한다.)  



# Upack PE 헤더 상세 분석(18)  
upack은 실행 압축기(pe packer)로 독특한 방식으로 pe헤더를 변형시켰다.  

1) 헤더 겹쳐쓰기 사용  
MZ헤더와 PE 헤더를 겹쳐써서 헤더 공간을 절약함과 동시에 복잡하게 만들었다. e_magic과 e_lfanew의 값만 변하지 않으면 상관없기 때문에 MZ 헤더 사이에 PE 헤더를 넣었고 e_lfanew의 값이 단축되었지만 계산 방식에는 어긋나지 않는다.  
2) 파일 헤더의 sizeofoptional 헤더 값 변경(PE의 IMAGE_OPTIONAL_HEADER 크기는 E0,PE+는 F0)  


