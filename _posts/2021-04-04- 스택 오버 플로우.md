---
layout: post
title: stack overflow
comment: False
description: 

---

# 문제 해석  
(gdb) p vuln  -함수 주소 알아내기  
$1 = {<text variable, no debug info>} 0x804843b <vuln>  
(gdb) b*0x804843b -함수 주소값에 break 걸기  
Breakpoint 1 at 0x804843b  
(gdb) r aaaabbbbccccdddd -실행  
Starting program: ~/example1 aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll  
Breakpoint 1, 0x0804843b in vuln ()  
(gdb) x/2wx $esp  -2*4=8bytes 만큼 esp부터 출력, 4byte는 return add고 나머지 4byte는 인자 argv[1]의 주소이다  
0xffffd520:	0x08048494	0xffffd74a  
(gdb) x/i 0x08048494 -return add를 4byte만큼 어셈블리로 출력  
   0x8048494 <main+30>:	add    $0x4,%esp  
(gdb) x/s 0xffffd74a -argv[1]의 문자열을 보여준다  
0xffffd74a:	"aaaabbbbccccddddeeeeffffgggghhhhiiiijjjjkkkkllll"  
(gdb)   
(gdb) disas vuln -해당 주소를 disassembly  
Dump of assembler code for function vuln:  
   0x0804843b <+0>:	push   ebp  
  ...  
  ...  
End of assembler dump.  
(gdb)   

# gdb 명령어  
x/ 범위,출력형식,범위 단위 +메모리 주소 또는 함수명  
출력형식: x=16진수, s=문자열(c는 최초 1byte 문자형으로 출력), i= 어셈블리, f=부동소수점  
범위 단위: b=1byte, h=2byte, w=4byte, g=8byte  -default=4byte
ex> x/10i main= main 함수 부터 40byte 어셈블리로 출력
