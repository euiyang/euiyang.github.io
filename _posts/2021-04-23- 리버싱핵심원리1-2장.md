## 1장
# 리버싱  
시스템의 구조, 기능, 동작을 분석해서 원리를 이해하며 단점을 보완하고 새로운 아이디어를 추가하는 작업  

# 리버싱 방법  
1) 정적 분석: 파일의 종류, 크기, 헤더, API, 내부 문자열, 인증서와 같은 파일의 겉모습을 관찰해서 분석하는 방법(디스 어셈블리도 포함)  
2) 동적 분석: 파일의 디버깅을 통해 코드 흐름과 메모리 상태 등을 살펴보는 방법, 프로그램 내부 구조와 동작 원리를 분석할 수 있다.  
- 정적분석으로 정보를 수집하면서 프로그램의 구조와 동작 원리를 예측하게 되면 이후의 동적 분석 방법에 도움을 준다. 두가지 방법을 적절히 사용하면 시간이 많이 줄어든다.  

# 소스코드, Hex 코드, 어셈블리 코드  
Hex 코드: 실행파일의 경우 2진수 형식으로 되어있는데, 이를 조금 보기 쉽게 16진수로 바꾼 코드이다.(ex>hex editor..)  
어셈블리 코드: 16진수의 hex 코드도 직관적으로 보긴 힘들다. 따라서 사람이 이해하기 쉽게 어셈블리 형태로 바꾼 것이다.  

# 패치와 크랙  
패치와 크랙 모두 프로그램의 파일이나 프로세스의 메모리 내용을 변경하는 행위이지만, 크랙의 경우 그 의도가 비합법적이고 비도덕적인 경우를 구분해서 말한다.  

## 2장  
# 디버거와 어셈블리어  
실행파일은 2진수 형식으로 되어 있으므로 디버거의 디스어셈블러를 통해 어셈블리 언어로 나타내어 준다.  

# 코드 분석  
![image](https://user-images.githubusercontent.com/65746019/115801669-46dd2300-a418-11eb-860d-bfaa3fb14629.png)
좌측부터 address, instruction, disassembled code, comment(디버거가 추가한 주석)  

처음 시작할때 entry point에서 시작함. entry point는 실행파일의 코드 시작점을 의미한다.  
프로그램을 재시작마다 entry point에서 시작하므로 필요한 부분으로 바로 가는 방법을 알아두는 것이 좋다.  
1) goto : ctrl+ G로 해당 주소로 간 다음 F4로 해당 커버 부분까지 실행한뒤 진행.  
2) break point: F2로 break point를 설치후 F9를 누르면 해당 부분까지 진행. alt+B를 통해 break point 목록 확인 가능.  
3) 주석: ; 로 해당 줄에 주석을 달고 주석 내용으로 찾아가는 방법.  
4) 레이블: :로 해당 label에 이름을 붙여줌. 이름이 달리면 주소값 대신 이름으로 주소를 대신할 수 있다.  

원하는 코드 빨리 찾아내기  
1) 사용하는 API 함수 찾기  
2) 문자열 검색 기능 사용  
3) 모듈간 호출 검색 기능 사용  
4) API 호출 목록이 보이지 않을 경우, 어짜피 API는 DLL에서 호출해 사용하기 때문에 라이브러리 자체에 break point를 사용한다.  
- 이 부분은 search for-> Name in all module을 사용하라고 되어 있는데 결국 모듈간 호출을 사용해서 해당 주소(DLL 내부)로 들어가라는 말 같다.  

# 패치 실습  
위의 내용으로 함수를 찾고 함수에 올라간 스택의 인자 주소로 가서 내용을 바꾸는 패치를 해본다.  
문자열 패치 방법  
1) 문자열 버퍼를 직접 수정  
2) 다른 메모리 영역에 새로운 문자열을 생성하여 전달  

첫번째 방법: 문자열 버퍼를 직접 수정  
1) 해당 인자의 주소로 이동  
![image](https://user-images.githubusercontent.com/65746019/115812125-d213e400-a42b-11eb-9039-10552194396c.png)
![image](https://user-images.githubusercontent.com/65746019/115812149-df30d300-a42b-11eb-9411-f8b1f1f6c623.png)
2) 해당 code window에서 덤프에서 따라가기로 이동  
![image](https://user-images.githubusercontent.com/65746019/115812183-ec4dc200-a42b-11eb-8ee2-5ac2aaad2487.png)
3) 해당 문자열 발견+ ctrl+c로 수정(알파벳 한 글자당 2바이트 사용+ 유니코드 문자열은 2바이트 크기의 NULL로 마침, 수정시 원본의 크기 넘어서는 수정 위험.)  
![image](https://user-images.githubusercontent.com/65746019/115812255-0f787180-a42c-11eb-9a2a-8c162e9d1abd.png)
![image](https://user-images.githubusercontent.com/65746019/115812309-21f2ab00-a42c-11eb-91a6-8b1a903ae3d8.png)

첫번째 방법의 장단점    
장점: 간편
단점: 기존 문자열 버퍼 크기 이상으로 수정하면 다른 주소에 영향을 줄 수 있다. 실행이 종료되면 사라짐.  


두번째 방법: 파일 생성  
1) 고치는 문자열이 기존 문자열보다 작을 때  
이 방법은 패치된 내용을 새로운 파일로 생성해서 저장하는 방법이다.  
책에서와 다르게 패치를 code window 부분에서 우클릭 패치를 누르면 됐다. 이거 한다고 시간만 드럽게 많이 보냈다.  
2) 고치는 문자열이 더 큰 경우  
현재 문자열의 주소를 사용하지 않고 다른 위치에 새로운 문자열 주소를 생성하고 그 주소를 인자로 넘겨준다.(PE File Format의 어느 부분을 사용해야 할까?)  
