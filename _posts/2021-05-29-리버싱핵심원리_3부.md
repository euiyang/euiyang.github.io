# 3부  
# Windows 메세지 후킹(21)  
훅이란 정보를 엿보거나 가로채는 것을 의미하고 실제로 하는 행위를 후킹이라한다.  

메세지 훅:  
windows는 GUI를 제공하고 event driven 방식으로 동작한다. 다양한 이벤트가 발생하면 OS가 응용 프로그램으로 메시지를 전송하는데,  
이러한 메시지를 훅하는 것이 메시지 훅이라 부른다.  

일반적인 경우 Windows 메시지 흐름:
1) 이벤트 발생-> WM_KEYDOWM 메시지가 OS message queue에 추가된다
2) OS가 어느 응용 프로그램에서 이벤트가 발생한지 파악해서 OS message queue-> application message queue로 이동  
3) 응용 프로그램이 WM_KEYDOWN 메시지 확인하고 event handler 호출  

하지만 메시지 훅이 설치 되었으면 OS에서 application으로 가는 도중에 훅 체인에서 메시지를 먼저 볼 수 있으며, 엿보기 뿐만  
아니라 메시지 자체의 변경, 전송 불가도 가능하다. 이러한 메시지 훅 기능은 window OS에서 기본으로 제공하며, OS에서 오고가는  
모든 메시지를 볼 수 있다.  


SetWindwosHookEx() 함수:  
![image](https://user-images.githubusercontent.com/65746019/120029343-f10c2400-c030-11eb-90f1-e0e8ea2feba5.png)  

이 함수를 이용해서 훅을 설치하면, 메시지가 발생했을 때 OS가 해당 DLL 파일을 해당 프로세스에 인젝션하고 훅을 호출한다.  

위 함수를 사용한 프로그램 코드를 보면  
![image](https://user-images.githubusercontent.com/65746019/120034308-d7baa600-c037-11eb-994a-a8dddc718c0b.png)  
![image](https://user-images.githubusercontent.com/65746019/120034331-e012e100-c037-11eb-8459-9a9a3e4b6446.png)  
위와 같이 KeyHook.dll을 불러와서 시작과 종료를 하는 간단한 프로그램이다.  

KeyHook.dll 파일 내부도 간단히 요약하면 실행하면 키보드 이벤트 발생 시에 실행 프로세스의 이름이 등록한 문자열과 같으면  
메시지를 가로채는 것이다.  

훅 코드 디버깅:  
KeyHook.dll의 HookStart() 함수 부분을 보면
![image](https://user-images.githubusercontent.com/65746019/120036015-73e5ac80-c03a-11eb-8813-c60dee8dfb1f.png)  
SetWindowsHookEX의 인자에 PUSH로 10001020과 2를 넣으므로  
idHook=2  
lpfn=10001020  
가 된다. 이 부분을 벗어나면 단순하게 q를 받으면 종료되는 부분이니 넘어간다.  
notepad를 디버깅 해보는 것은 다음에 해보자. (설정에서 dll 접근시 멈춤 켜놓으면 새로운 dll에서 멈춘다.)  


# 악의적인 목적의 키로거(22)  
조심하자  


# DLL 인젝션  
DLL 인젝션은 실행 중인 다른 프로세스가 LoadLibrary API를 호출하도록 명령해서 사용자가 원하는 DLL을 로딩시키는 것이다.  
![image](https://user-images.githubusercontent.com/65746019/120039858-8e228900-c040-11eb-91c1-a4efb786529a.png)  

위의 그림처럼 myhack.dll강제로 삽입하면 해당 프로세스의 메모리 접근 권한을 가지게 되므로 어떤 일이든 수행 가능하므로 다음과 같은 작업을 할 수 있다.  
1) 기능 개선 및 버그 패치  
2) 메시지 후킹  
3) API 후킹  
4) 기타 응용 프로그램  
5) 악성 코드  


DLL 인젝션 방법  
1) 원격 스레드 생성(CreateRemoteThread() API 사용)  
2) 레지스트리 이용(APPInit_DLLs값)  
3) 메시지 후킹(SetWindowsHookEx() API 사용)  

1) 원격 스레드 생성 방법  
인젝션할 dll 코드  
![image](https://user-images.githubusercontent.com/65746019/120044804-83b8bd00-c049-11eb-9e7b-be5551768102.png)  
![image](https://user-images.githubusercontent.com/65746019/120044815-89ae9e00-c049-11eb-9019-dd6fe06fe619.png)  

내용은 메인에서 새 쓰레드를 생성 후, 새 쓰레드에서 URLDownloadToFile()을 사용해서 해당 URL에서 파일을 다운 받는 것과같이 단순한 코드이다.  

실행 파일 코드  
![image](https://user-images.githubusercontent.com/65746019/120045300-9ed7fc80-c04a-11eb-91bc-02cfa33e178e.png)  
![image](https://user-images.githubusercontent.com/65746019/120045323-b1523600-c04a-11eb-9fb8-399bbd55d952.png)  

메인 함수에서 사용하는 injectdll 함수는  
1) hProcess = OpenProcess() 에서 hProcess라는 프로세스 핸들을 이용해 프로세스를 제어할 수 있다. OpenProcess에서 잘못되면 false로 함수가 종료된다.  
2) pRemoteBuf= VirtualAllocEx(hProcess, NuLL,dwbufSize,MEM_COMMIT,PAGE_READWRITE) 에서 로딩할 DLL의 경로를 알려준다. 이 경로에 해당하는 DLL 파일을 VirtualAllocEx() 함수를 통해 노트패드의 메모리 공간에 DLL 파일 경로 문자열 길이만큼 버퍼를 할당한다.  
3) WriteProcessMemory(hProcess,pRemoteBuf,(LPVOID)szDllName, dwBufSize,NULL) 에서 2)번에서 pRemote에 들어간 DLL 문자열의 주소에 WriteProcessMemory() API를 이용해서 상대 프로세스에 DLL 경로를 써주게 된다.  
4) LoadLibrary() API 호출을 위한 주소가 필요하므로 GetProcAddress를 통해 할당받아준다. 하지만 이 코드에서는 상대 프로세스의 kernel32.dll이 아닌 현재 프로세스의 kernel32.dll에서 GetModuleHandle()로 위치를 받아오고 있지만 같은 os상에서 같은 dll 주소를 사용하면 문제없다.(윈도우에서 dll 초기 로딩 이외에는 따로 로딩해오지 않고 주소만 그쪽으로 매핑해준다.)  
5) hThread=CreateRemoteThread(hProcess,NULL, 0, pThreadProc(상대 프로세스 내의 loadlibrary 주소), pRemoteBuf(상대 프로세스 내의 실행할 dll 주소), 0 ,NULL) 로 원격 쓰레드를 실행한다. CreateRemoteThread() API로 상대 프로세스에게 스레드를 실행시켜주면 상대 프로세스에 있는 lpStartAddress 멤버의 LoadLibrary API를 lpParameter 멤버의 할당 해놓은 주소에 넣어준다.(프로세스 DLL 인젝션에 쓰레드 API를 사용하는 이유는 쓰레드와 Loadlibrary API가 모두 4바이트 인자를 받고 4바이트 리턴을 하기 때문에 사용한다고 한다.) 따라서 CreateRemoteThread()는 LoadLibrary를 호출하는 역할을 하는 것이다.  
![image](https://user-images.githubusercontent.com/65746019/120047950-df3a7900-c050-11eb-8467-6b653572054a.png)  


2) 레지스트리 이용 방법  
윈도우 레지스트리 항목 중에 APPInit_DLLs 항목에는 원하는 DLL 경로 문자열을 쓰고, LoadAppInit_DLLs의 레지스트리 항목에는 1을 넣으면 모든 프로세스(User32.dll을 로딩하는 모든 프로세스)에서 해당 dll을 포함해서 실행한다.  
![image](https://user-images.githubusercontent.com/65746019/120048896-6557bf00-c053-11eb-9487-c8614950d344.png)  
![image](https://user-images.githubusercontent.com/65746019/120048905-6b4da000-c053-11eb-93bf-0610756347a3.png)  

위 코드는 일단 switch case 문으로 파일 명이 같으면 dll을 실행하는 것이다.  


3) 메시지 후킹(SetWindowsHookEx()) 사용  
위의 API를 사용하면 OS에서 hook을 담은 dll을 프로세스에게 강제로 인젝션 시킨다.  




















